# 한수 크기 : 2^N * 2^N 2차 배열을 Z 모양으로 탐색

#n>1 인경우, 배열을 크기가 2^(N-1) * 2^(N-1) 로 4등분 후 재귀적으로 순서대로 방문

# r행 c열은 몇번째로 방문하는지 출력

# 1 <= N <= 15  &  0 <= r,c < 2^N


# 2, [3, 1] = > 11번쨰
# 
#분할 정복

# N//2 해가면서 어디에 속하는지 O(log(n))
#N=3 기준                                  # 4분면 (0,1,2,3) 으로 
#N=2    # 2**(N-1) = 2**2 ==> r>=4,c>=4 ==> (4사분면) * (2**(N-1))**2 가 해당 사분면 스타트 (이 경우 48)
#N=1    # 2**(N-1) = 2    ==> r%4 >= 2, c%4 >=2 ==> (4사분면) * (2**(N-1))**2 (48+12)
#N=0    # 2**(N-1) = 1    ==> r%2 >= 1, r%2 >=1 ==> (4사분면) * (2**(N-1))**2  (60+3)

import sys

N,r,c = map(int,sys.stdin.readline().split())
result = 0
for i in range(N,0,-1):
    
    quadrant = 0
    x = (2**(i-1))
    if r>=x:
        quadrant+=2
    if c>=x:
        quadrant+=1
    result += quadrant*(x**2)

    r,c = r%x,c%x

print(result)

